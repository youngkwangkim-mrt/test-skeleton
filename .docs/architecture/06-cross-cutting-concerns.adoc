= Cross-Cutting Concerns
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 2
:sectnums:
:last-verified: 2026-02-13

== Overview

Cross-cutting concerns are aspects of the system that span multiple layers and modules. The hexagonal-skeleton project implements these concerns systematically through filters, interceptors, AOP aspects, and context propagation mechanisms.

This document covers:

* Request tracing and distributed tracing
* MDC context propagation (sync/async/coroutines)
* Logging architecture
* AOP aspects and custom annotations
* Virtual threads and async configuration

== Request Tracing

=== UUID v7 Application Trace ID

The system generates a **UUID v7 Application Trace ID** for every incoming request using `AppTraceFilter`.

.Trace ID Generation Flow
[mermaid]
----
sequenceDiagram
    participant Client
    participant AppTraceFilter
    participant MDC
    participant Application
    participant Response

    Client->>AppTraceFilter: HTTP Request
    AppTraceFilter->>AppTraceFilter: Generate UUID v7
    AppTraceFilter->>MDC: Store as APP_TRACE_ID
    AppTraceFilter->>Response: Set X-ZZ-TraceId header
    AppTraceFilter->>Application: Process request
    Application-->>AppTraceFilter: Complete
    AppTraceFilter->>Response: Add X-ZZ-Res-Ts header
    AppTraceFilter->>MDC: Clear
    AppTraceFilter-->>Client: HTTP Response
----

==== Implementation

[source,kotlin]
----
@WebFilter(filterName = "AppTraceFilter", urlPatterns = ["/**"])
@Order(Ordered.HIGHEST_PRECEDENCE + 1)
class AppTraceFilter(private val tracer: Tracer) : OncePerRequestFilter() {

    override fun doFilterInternal(
        request: HttpServletRequest,
        response: HttpServletResponse,
        filterChain: FilterChain,
    ) {
        val appTraceId = Uuid.generateV7().toString()
        setupTraceContext(response, appTraceId)

        try {
            filterChain.doFilter(request, response)
        } finally {
            response.setHeader(APP_RESPONSE_TIMESTAMP, System.currentTimeMillis().toString())
            MDC.clear()
        }
    }

    private fun setupTraceContext(response: HttpServletResponse, appTraceId: String) {
        MDC.put(APP_TRACE_ID, appTraceId)
        response.setHeader(APP_TRACE_ID, appTraceId)
        response.setHeader(X_B3_TRACE_ID, currentTraceId())
    }
}
----

==== Trace Headers

The system uses multiple trace headers for comprehensive request tracking:

[cols="1,2,2", options="header"]
|===
| Header Name | Purpose | Set By

| `X-ZZ-TraceId`
| Application-level trace ID (UUID v7)
| AppTraceFilter

| `X-ZZ-Req-Ts`
| Request timestamp
| Client/Gateway

| `X-ZZ-Res-Ts`
| Response timestamp
| AppTraceFilter

| `X-ZZ-AccessId`
| Access/User identifier
| Application

| `X-B3-TraceId`
| Distributed tracing (Brave/Zipkin)
| Micrometer Tracing

| `X-B3-SpanId`
| Current span identifier
| Micrometer Tracing
|===

All trace header constants are defined in `GlobalConstants.kt`:

[source,kotlin]
----
object TraceHeader {
    const val APP_REQUEST_TIMESTAMP = "X-ZZ-Req-Ts"
    const val APP_RESPONSE_TIMESTAMP = "X-ZZ-Res-Ts"
    const val APP_TRACE_ID = "X-ZZ-TraceId"
    const val APP_ACCESS_ID = "X-ZZ-AccessId"
    const val X_B3_TRACE_ID = "X-B3-TraceId"
    const val X_B3_SPAN_ID = "X-B3-SpanId"
}
----

=== Distributed Tracing

The system integrates with **Micrometer Tracing** and **Brave** for distributed tracing support.

* **X-B3-TraceId**: Propagated across microservices for distributed request correlation
* **X-B3-SpanId**: Identifies individual operations within a trace
* **Integration**: Automatic via Spring Boot Actuator + Micrometer Tracing

Both Application Trace ID (`X-ZZ-TraceId`) and Distributed Trace ID (`X-B3-TraceId`) are included in the `Meta` object of `ApiResource` responses.

== MDC Context Propagation

**MDC (Mapped Diagnostic Context)** allows thread-local storage of diagnostic information. The system ensures MDC is propagated across:

* Synchronous processing
* Asynchronous operations
* Kotlin coroutines

.MDC Propagation Architecture
[mermaid]
----
graph TD
    AppTraceFilter[AppTraceFilter<br/>Generate Trace ID]
    MDC[MDC Context]
    Sync[Synchronous Request<br/>Filter Chain]
    Async[Async Operations<br/>@Async / VirtualThreadTaskExecutor]
    Coroutines[Kotlin Coroutines<br/>runBlockingWithMDC]

    AppTraceFilter --> MDC
    MDC --> Sync
    MDC --> Async
    MDC --> Coroutines

    Sync -->|Auto Propagation| Handler[Controllers/Services]
    Async -->|ContextPropagatingTaskDecorator| AsyncTask[Async Task]
    Coroutines -->|MDCContext| CoroutineTask[Suspend Block]
----

=== Synchronous Propagation

MDC is automatically propagated in synchronous request processing:

* Set in `AppTraceFilter` at request start
* Available throughout filter chain, interceptors, controllers, services
* Cleared in `AppTraceFilter` finally block

=== Asynchronous Propagation

For `@Async` methods and executor-based async operations, context is propagated using `ContextPropagatingTaskDecorator`.

.Configuration
[source,kotlin]
----
@Configuration
class CommonWebConfig {

    @Bean
    fun contextPropagatingTaskDecorator(): ContextPropagatingTaskDecorator {
        return ContextPropagatingTaskDecorator()
    }
}
----

.AsyncConfig
[source,kotlin]
----
@Configuration
class AsyncConfig(
    private val contextPropagatingTaskDecorator: ContextPropagatingTaskDecorator
) : AsyncConfigurer {

    override fun getAsyncExecutor(): Executor? {
        return asyncVirtualThreadTaskExecutor()
    }

    private fun asyncVirtualThreadTaskExecutor(): AsyncTaskExecutor {
        val executorAdapter = TaskExecutorAdapter(VirtualThreadTaskExecutor(ASYNC_THREAD_PREFIX))
        executorAdapter.setTaskDecorator(contextPropagatingTaskDecorator)
        return executorAdapter
    }
}
----

=== Coroutines Propagation

Kotlin coroutines require explicit MDC propagation using utilities from the `common` module.

[cols="1,2,2", options="header"]
|===
| Function | Purpose | Usage

| `runBlockingWithMDC`
| Blocking coroutine with MDC
| Top-level blocking call

| `asyncWithMDC`
| Structured async with MDC
| Parallel tasks within scope

| `launchWithMDC`
| Fire-and-forget with MDC
| Background jobs within scope
|===

.Example
[source,kotlin]
----
import com.myrealtrip.common.utils.coroutine.*

// Blocking with MDC
runBlockingWithMDC {
    val result1 = asyncWithMDC { fetchData1() }
    val result2 = asyncWithMDC { fetchData2() }
    result1.await() + result2.await()
}

// Custom dispatcher
runBlockingWithMDC(Dispatchers.IO) {
    // IO-bound work with MDC
}
----

These utilities internally use `kotlinx.coroutines.slf4j.MDCContext()` to propagate MDC across coroutine boundaries.

== Logging Architecture

The logging architecture consists of multiple layers:

* Request/Response logging via interceptors
* Method execution tracing via AOP
* HTTP client logging via interceptors
* Custom annotations for fine-grained control

.Logging Layers
[mermaid]
----
graph TD
    Request[Incoming Request]
    AppTraceFilter[AppTraceFilter]
    LogInterceptor[LogInterceptor<br/>Request Info]
    LogResponseBodyInterceptor[LogResponseBodyInterceptor<br/>Response Body]
    LogTraceAspect[LogTraceAspect<br/>Method Tracing]
    Controller[Controller]
    Service[Service]
    HttpClient[HTTP Client]
    HttpLoggingInterceptor[HttpLoggingInterceptor<br/>External Calls]

    Request --> AppTraceFilter
    AppTraceFilter --> LogInterceptor
    LogInterceptor --> Controller
    Controller --> LogTraceAspect
    LogTraceAspect --> Service
    Service --> HttpClient
    HttpClient --> HttpLoggingInterceptor

    Controller -.->|afterCompletion| LogResponseBodyInterceptor
----

=== Request Logging

`LogInterceptor` logs incoming request details.

.Logged Information
* Server IP and Client IP
* Request method and URI
* Selected headers (authorization, content-type, tracing headers)
* Request parameters (query string)
* Request body (from ContentCachingRequestWrapper)

.Example Output
----
# ==> REQUEST INFO ::
ServerIp = 192.168.1.10 , ClientIp = 203.0.113.42
RequestURI = POST /api/users
Headers:
  content-type = application/json
  x-b3-traceid = 5f8a9c3d2e1b4a6f
RequestBody = {"name":"John","email":"john@example.com"}
----

.Excluding Request Logs
Use `@ExcludeRequestLog` annotation to skip logging for specific endpoints:

[source,kotlin]
----
@GetMapping("/health")
@ExcludeRequestLog
fun healthCheck(): String = "OK"
----

NOTE: `@ExcludeRequestLog` only applies in **production** environment.

=== Response Body Logging

`LogResponseBodyInterceptor` logs response bodies for annotated methods.

[source,kotlin]
----
@GetMapping("/{id}")
@LogResponseBody(maxLength = 5000, logLevel = Level.INFO)
fun getUserById(@PathVariable id: Long): ApiResource<UserDto> {
    return ApiResource.success(userService.findById(id))
}
----

.Annotation Parameters
[cols="1,1,2", options="header"]
|===
| Parameter | Default | Description

| `value`
| `true`
| Enable/disable logging

| `maxLength`
| `2000`
| Maximum characters to log

| `printAll`
| `false`
| Print entire response (ignore maxLength)

| `logLevel`
| `Level.INFO`
| Log level (INFO/DEBUG/TRACE/WARNING/ERROR)
|===

=== Method Tracing

`LogTraceAspect` provides hierarchical method execution tracing with timing information.

.Traced Methods
* All `*Controller` classes
* All `*Service` classes
* Methods annotated with `@LogTrace`

.Excluded Methods
* Methods annotated with `@ExcludeLogTrace`

.Example Output
----
|--> UserController.getUser(..)
|    |--> UserService.findById(..)
|    |<-- UserService.findById(..) elapsed=15ms
|<-- UserController.getUser(..) elapsed=18ms
----

The aspect uses `ThreadLocalLogTrace` to maintain call hierarchy depth using `ThreadLocal`:

[source,kotlin]
----
class ThreadLocalLogTrace : LogTrace {
    private val traceIdHolder = ThreadLocal<TraceId>()

    override fun begin(message: String): TraceStatus {
        val traceId = syncTraceId()
        val prefix = buildPrefix(START_PREFIX, traceId.level)
        logger.debug { "$prefix$message" }
        return TraceStatus(traceId, System.nanoTime(), message)
    }

    private fun buildPrefix(prefix: String, level: Int): String =
        INDENT.repeat(level - 1) + prefix
}
----

.Output Prefixes
[cols="1,2", options="header"]
|===
| Prefix | Meaning

| `\|-\->`
| Method entry

| `\|<--`
| Method exit (success)

| `\|<X-`
| Method exit (exception)

| `\|    `
| Indentation (call depth)
|===

=== HTTP Client Logging

`HttpLoggingInterceptor` logs outbound HTTP requests/responses from `RestClient`.

[source,kotlin]
----
@Bean
fun todoClientGroupConfigurer(): RestClientHttpServiceGroupConfigurer {
    return RestClientHttpServiceGroupConfigurer { groups ->
        groups.filterByName("todo")
            .forEachClient { _, builder ->
                builder.baseUrl("https://jsonplaceholder.typicode.com")
                    .requestInterceptor(HttpLoggingInterceptor("TodoClient", Level.FULL))
            }
    }
}
----

.Logging Levels
[cols="1,2", options="header"]
|===
| Level | Logged Information

| `SIMPLE`
| Request line, Response status, Elapsed time

| `FULL`
| SIMPLE + Headers + Request/Response bodies
|===

.Example Output (FULL mode)
----
[TodoClient#findAll] ---> GET https://jsonplaceholder.typicode.com/todos
[TodoClient#findAll] content-type: application/json
[TodoClient#findAll] ---> END (0-byte body)
[TodoClient#findAll] <--- 200 (245ms)
[TodoClient#findAll] content-type: application/json
[TodoClient#findAll] [{"id":1,"title":"Task 1",...}]
[TodoClient#findAll] <--- END (1523-byte body)
----

The interceptor integrates with `HttpExchangeMethodAspect` to capture method names from `@HttpExchange` interfaces for better log tagging.

== AOP Aspects

The system uses Spring AOP for cross-cutting concerns.

[cols="1,1,1,2", options="header"]
|===
| Aspect | Trigger | Module | Purpose

| `LogTraceAspect`
| `TracePointcuts.all()`
| `common-web`
| Method execution tracing with timing

| `CheckIpAspect`
| `@CheckIp` annotation
| `common-web`
| IP whitelist validation

| `HttpExchangeMethodAspect`
| `@HttpExchange` methods
| `infrastructure`
| Capture method name for HTTP client logging

| `RedisLockAspect`
| `@RedisLock` annotation
| `infrastructure`
| Distributed lock management

| `RedisCacheAspect`
| `@RedisCache` annotation
| `infrastructure`
| Redis-based caching
|===

=== LogTraceAspect

Traces method execution with hierarchical visualization.

.Pointcut Definition
[source,kotlin]
----
class TracePointcuts {

    @Pointcut("@annotation(com.myrealtrip.common.annoatations.ExcludeLogTrace)")
    fun excludeLogTraceAnnotation() = Unit

    @Pointcut("@annotation(com.myrealtrip.common.annoatations.LogTrace)")
    fun logTraceAnnotation() = Unit

    @Pointcut("execution(* com.myrealtrip..*Controller.*(..))")
    fun allController() = Unit

    @Pointcut("execution(* com.myrealtrip..*Service.*(..))")
    fun allService() = Unit

    @Pointcut("(allController() || allService() || logTraceAnnotation()) && !excludeLogTraceAnnotation()")
    fun all() = Unit
}
----

.Aspect Implementation
[source,kotlin]
----
@Aspect
@Order(2)
class LogTraceAspect(private val logTrace: LogTrace) {

    @Around("com.myrealtrip.commonweb.aop.logtrace.TracePointcuts.all()")
    fun traceMethod(joinPoint: ProceedingJoinPoint): Any? {
        val status = logTrace.begin(joinPoint.signature.toShortString())
        return try {
            joinPoint.proceed().also { logTrace.end(status) }
        } catch (e: Exception) {
            logTrace.exception(status, e)
            throw e
        }
    }
}
----

=== CheckIpAspect

Validates client IP against whitelist patterns.

[source,kotlin]
----
@Aspect
@Order(3)
class CheckIpAspect {

    @Pointcut("@within(com.myrealtrip.common.annoatations.CheckIp) || @annotation(com.myrealtrip.common.annoatations.CheckIp)")
    fun checkIpPointcut() {}

    @Before("checkIpPointcut()")
    fun checkClientIp(joinPoint: JoinPoint) {
        val annotation = findAnnotation(joinPoint) ?: return
        val clientIp = IpAddrUtil.getClientIp()
        val allowedPatterns = IpWhitelist.LOCAL_IPS + annotation.allowedIps.toList()

        if (!IpWhitelist.isWhitelisted(clientIp, allowedPatterns)) {
            throw UnauthorizedIpException(clientIp)
        }
    }
}
----

.Usage
[source,kotlin]
----
@RestController
@RequestMapping("/admin")
@CheckIp(allowedIps = ["192.168.1.0/24", "10.0.0.*"])
class AdminController {
    // All endpoints restricted to specified IPs
}
----

=== HttpExchangeMethodAspect

Captures method name from `@HttpExchange` interfaces for HTTP client logging.

[source,kotlin]
----
@Aspect
@Component
class HttpExchangeMethodAspect {

    @Around("@within(org.springframework.web.service.annotation.HttpExchange)")
    fun captureMethodName(joinPoint: ProceedingJoinPoint): Any? {
        HttpExchangeMethodContext.set(joinPoint.signature.name)
        return try {
            joinPoint.proceed()
        } finally {
            HttpExchangeMethodContext.clear()
        }
    }
}
----

This enables `HttpLoggingInterceptor` to log with the actual interface method name (e.g., `[TodoClient#findById]`) instead of generic names.

== Custom Annotations Reference

[cols="1,1,1,3", options="header"]
|===
| Annotation | Module | Target | Purpose

| `@LogTrace`
| `common`
| Method
| Force method tracing even if not in *Controller/*Service

| `@ExcludeLogTrace`
| `common`
| Method
| Exclude method from tracing

| `@LogResponseBody`
| `common`
| Method
| Log response body (configurable maxLength, logLevel)

| `@ExcludeRequestLog`
| `common`
| Method
| Skip request logging (production only)

| `@CheckIp`
| `common`
| Class, Method
| Validate client IP against whitelist patterns
|===

=== @LogTrace

Force log tracing for specific methods.

[source,kotlin]
----
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class LogTrace(
    val logLevel: Level = Level.DEBUG
)
----

.Usage
[source,kotlin]
----
@LogTrace
fun criticalBusinessLogic() {
    // This will be traced even though it's not in *Controller/*Service
}
----

=== @ExcludeLogTrace

Exclude methods from automatic tracing.

[source,kotlin]
----
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class ExcludeLogTrace
----

.Usage
[source,kotlin]
----
@Service
class UserService {

    @ExcludeLogTrace
    fun internalHelperMethod() {
        // This method will NOT be traced
    }
}
----

=== @LogResponseBody

Log response body with configurable truncation and log level.

[source,kotlin]
----
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class LogResponseBody(
    val value: Boolean = true,
    val maxLength: Int = 2_000,
    val printAll: Boolean = false,
    val logLevel: Level = Level.INFO
)
----

.Usage
[source,kotlin]
----
@GetMapping("/large-data")
@LogResponseBody(maxLength = 10_000, logLevel = Level.DEBUG)
fun getLargeData(): ApiResource<List<DataDto>> {
    // Response body logged at DEBUG level, up to 10,000 characters
}
----

=== @ExcludeRequestLog

Skip request logging for specific endpoints (production only).

[source,kotlin]
----
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class ExcludeRequestLog
----

.Usage
[source,kotlin]
----
@GetMapping("/health")
@ExcludeRequestLog
fun healthCheck(): String = "OK"
----

=== @CheckIp

Validate client IP against whitelist patterns.

[source,kotlin]
----
@Target(AnnotationTarget.CLASS, AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class CheckIp(
    val allowedIps: Array<String> = [""]
)
----

.Supported Patterns
* Exact: `192.168.1.100`
* Wildcard: `192.168.1.*`
* CIDR: `192.168.1.0/24`
* All: `*` (allow all IPs)

.Usage
[source,kotlin]
----
@RestController
@RequestMapping("/api/v1/users")
class UserController {

    @PostMapping
    @CheckIp(allowedIps = ["192.168.1.0/24", "10.0.0.*"])
    fun createUser(@RequestBody request: CreateUserRequest): ApiResource<UserDto> {
        // Only allowed IPs can access
    }
}
----

NOTE: Local IPs (127.0.0.1, localhost, ::1) are always allowed.

== Virtual Threads

The system leverages **Java 21 Virtual Threads** for efficient async operations.

=== Configuration

Virtual threads are configured at the application level:

.application.yml (if using property-based config)
[source,yaml]
----
spring:
  threads:
    virtual:
      enabled: true
----

=== AsyncConfig

The `AsyncConfig` uses `VirtualThreadTaskExecutor` with MDC propagation:

[source,kotlin]
----
@Configuration
class AsyncConfig(
    private val contextPropagatingTaskDecorator: ContextPropagatingTaskDecorator
) : AsyncConfigurer {

    companion object {
        const val ASYNC_THREAD_PREFIX: String = "async-vt-"
    }

    override fun getAsyncExecutor(): Executor? {
        return asyncVirtualThreadTaskExecutor()
    }

    private fun asyncVirtualThreadTaskExecutor(): AsyncTaskExecutor {
        val executorAdapter = TaskExecutorAdapter(VirtualThreadTaskExecutor(ASYNC_THREAD_PREFIX))
        executorAdapter.setTaskDecorator(contextPropagatingTaskDecorator)
        return executorAdapter
    }
}
----

=== Benefits

* **Low Memory Footprint**: Virtual threads are lightweight (compared to platform threads)
* **High Concurrency**: Millions of virtual threads can run concurrently
* **Simplified Code**: No need for reactive programming or manual thread pool management
* **MDC Propagation**: Context automatically propagated via `ContextPropagatingTaskDecorator`

=== Usage

[source,kotlin]
----
@Service
class UserService {

    @Async
    fun processUserAsync(userId: Long) {
        // Runs on virtual thread
        // MDC context automatically propagated
        logger.info { "Processing user $userId on ${Thread.currentThread().name}" }
    }
}
----

== Summary

The hexagonal-skeleton project implements comprehensive cross-cutting concerns:

.Key Features
* **Request Tracing**: UUID v7 Application Trace ID + Distributed Tracing (B3)
* **MDC Propagation**: Sync, Async, and Coroutines support
* **Logging**: Multi-layer logging (request, response, method tracing, HTTP client)
* **AOP Aspects**: Tracing, IP validation, HTTP client method capture
* **Annotations**: Fine-grained control over logging and security
* **Virtual Threads**: Efficient async operations with automatic context propagation

These mechanisms ensure:

* **Observability**: Complete request tracing and timing information
* **Maintainability**: Consistent logging patterns across all layers
* **Performance**: Efficient async operations with virtual threads
* **Security**: IP-based access control
* **Developer Experience**: Declarative configuration via annotations

For more details, see:

* xref:05-common-web-module.adoc[Common Web Module]
* xref:02-module-structure.adoc[Module Structure]
* xref:07-caching-strategy.adoc[Caching Strategy] (for Redis aspects)
