= Caching Strategy
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 2
:sectnums:
:last-verified: 2026-02-13

== Overview

The hexagonal-skeleton project implements a **two-tier caching architecture** combining local in-memory cache (L1: Caffeine) and distributed cache (L2: Redis) to optimize performance and scalability.

[mermaid]
----
graph LR
    Request[Request] --> L1[L1: Caffeine Cache]
    L1 -->|Cache Miss| L2[L2: Redis Cache]
    L2 -->|Cache Miss| DB[Database]
    DB -->|Store| L2
    L2 -->|Store| L1
    L1 -->|Return| Response[Response]
----

=== Key Benefits

[cols="1,3"]
|===
|Benefit |Description

|Performance
|Local cache provides microsecond access time for frequently accessed data

|Scalability
|Distributed cache enables horizontal scaling across multiple application instances

|Resilience
|Graceful degradation: if Redis fails, the system continues with database queries

|Flexibility
|Multiple caching strategies: annotation-based, programmatic API, distributed locking
|===

== L1: Caffeine Cache (Primary)

Caffeine is configured as the **primary cache manager** for local in-memory caching.

=== Configuration

[source,kotlin]
----
@Bean
@Primary
fun caffeineCacheManager(): CacheManager {
    return CaffeineCacheManager().apply {
        setCaffeine(
            Caffeine.newBuilder()
                .maximumSize(200)
                .expireAfterWrite(Duration.ofMinutes(30))
                .expireAfterAccess(Duration.ofMinutes(10))
                .evictionListener(RemovalListener { key, _, cause ->
                    logger.debug { "# ==> Key $key was evicted ($cause)" }
                })
                .recordStats()
                .scheduler(Scheduler.systemScheduler())
        )
    }
}
----

=== Settings

[cols="1,1,3"]
|===
|Setting |Value |Description

|`maximumSize`
|200 entries
|Maximum number of cache entries per cache

|`expireAfterWrite`
|30 minutes
|Entries expire 30 minutes after creation

|`expireAfterAccess`
|10 minutes
|Entries expire 10 minutes after last access

|`recordStats`
|enabled
|Cache statistics recording for monitoring

|`evictionListener`
|enabled
|Logs cache evictions at DEBUG level
|===

=== Usage with @Cacheable

Since Caffeine is the **primary** cache manager, you don't need to specify `cacheManager` parameter:

[source,kotlin]
----
@Cacheable(cacheNames = ["users"], key = "#id")
fun findUserById(id: Long): User? {
    return userRepository.findById(id).orElse(null)
}

@CacheEvict(cacheNames = ["users"], key = "#id")
fun updateUser(id: Long, user: User): User {
    return userRepository.save(user)
}
----

== L2: Redis Cache (Distributed)

Redis provides distributed caching using Redisson client, enabling cache sharing across multiple application instances.

=== Configuration

[source,kotlin]
----
@Bean
@Qualifier("redisCacheManager")
fun redisCacheManager(redissonClient: RedissonClient): CacheManager {
    val config = hashMapOf(
        DEFAULT to RedissonCacheConfig(
            Duration.ofMinutes(30).toMillis(),  // ttl
            Duration.ofMinutes(10).toMillis()   // maxIdleTime
        ),
        SHORT_LIVED to RedissonCacheConfig(
            Duration.ofMinutes(10).toMillis(),
            Duration.ofMinutes(5).toMillis()
        ),
        // ... other tiers
    )
    return RedissonSpringCacheManager(redissonClient, config)
}
----

=== Cache Tiers

[cols="1,1,1,3"]
|===
|Cache Name |TTL |Max Idle Time |Usage

|`SHORT_LIVED`
|10 minutes
|5 minutes
|Search results, real-time data, frequently changing data

|`DEFAULT`
|30 minutes
|10 minutes
|General query results, standard entity lookups

|`MID_LIVED`
|1 hour
|20 minutes
|Infrequently changed data, aggregated results

|`LONG_LIVED`
|24 hours
|4 hours
|Code tables, configuration, static reference data
|===

=== Usage with @Cacheable

To use Redis cache, specify `cacheManager = "redisCacheManager"`:

[source,kotlin]
----
import com.myrealtrip.infrastructure.cache.CacheConfig.Companion.DEFAULT
import com.myrealtrip.infrastructure.cache.CacheConfig.Companion.SHORT_LIVED
import com.myrealtrip.infrastructure.cache.CacheConfig.Companion.LONG_LIVED

// Standard caching with DEFAULT tier
@Cacheable(
    cacheManager = "redisCacheManager",
    cacheNames = [DEFAULT],
    key = "#id"
)
fun findOrderById(id: Long): Order? {
    return orderRepository.findById(id).orElse(null)
}

// Short-lived cache for search results
@Cacheable(
    cacheManager = "redisCacheManager",
    cacheNames = [SHORT_LIVED],
    key = "'search:' + #query"
)
fun searchProducts(query: String): List<Product> {
    return productRepository.search(query)
}

// Long-lived cache for code tables
@Cacheable(
    cacheManager = "redisCacheManager",
    cacheNames = [LONG_LIVED],
    key = "'codes:' + #type"
)
fun getCodesByType(type: String): List<Code> {
    return codeRepository.findByType(type)
}

// Cache eviction
@CacheEvict(
    cacheManager = "redisCacheManager",
    cacheNames = [DEFAULT],
    key = "#id"
)
fun updateOrder(id: Long, order: Order): Order {
    return orderRepository.save(order)
}
----

== Redis Functions (Programmatic API)

For more complex caching scenarios, use the programmatic Redis API provided by `RedisCacheAspect`.

=== redisGet - Cache-Aside Pattern

Retrieves from cache or computes and caches the result if not present.

[source,kotlin]
----
import com.myrealtrip.infrastructure.redis.redisGet
import java.time.Duration

// Basic usage with default 5-minute TTL
val users = redisGet("users:all") {
    userRepository.findAll()
}

// Custom TTL
val flight = redisGet(
    key = "flight:${flightId}",
    ttl = Duration.ofHours(1)
) {
    flightService.findById(flightId)
}

// Force refresh cache
val freshData = redisGet(
    key = "stats:daily",
    force = true
) {
    statsService.calculateDailyStats()
}

// Bypass cache (useful for testing)
val directResult = redisGet(
    key = "data:test",
    bypass = true
) {
    dataService.getData()
}

// Cache null or empty results to prevent repeated DB queries
val maybeEmpty = redisGet(
    key = "search:${query}",
    cacheNullOrEmpty = true,
    ttl = Duration.ofMinutes(1)
) {
    searchService.search(query)
}
----

==== Parameters

[cols="1,1,1,3"]
|===
|Parameter |Type |Default |Description

|`key`
|`String`
|required
|Cache key suffix (will be prefixed automatically)

|`ttl`
|`Duration`
|5 minutes
|Time-to-live for cached value

|`bypass`
|`Boolean`
|`false`
|Skip cache and execute function directly

|`force`
|`Boolean`
|`false`
|Refresh cache by executing function unconditionally

|`cacheNullOrEmpty`
|`Boolean`
|`false`
|Cache null values and empty collections
|===

==== Behavior

* **Default**: Null values and empty collections are NOT cached (prevents cache pollution)
* **cacheNullOrEmpty = true**: Caches null and empty collections (useful to prevent repeated DB queries)
* **Graceful fallback**: On Redis failure, executes function directly and returns result

=== redisSetAsync - Async Cache Population

Executes function and asynchronously stores the result in Redis.

[source,kotlin]
----
import com.myrealtrip.infrastructure.redis.redisSetAsync

// Compute and cache asynchronously
val report = redisSetAsync(
    key = "report:monthly:${month}",
    ttl = Duration.ofHours(24)
) {
    reportService.generateMonthlyReport(month)
}

// Update cache after data modification
val updatedUser = redisSetAsync("user:${userId}") {
    userService.updateUser(userId, userData)
}

// Cache even if result is null or empty
val searchResult = redisSetAsync(
    key = "search:${query}",
    cacheNullOrEmpty = true
) {
    searchService.search(query)
}
----

==== Parameters

[cols="1,1,1,3"]
|===
|Parameter |Type |Default |Description

|`key`
|`String`
|required
|Cache key suffix

|`ttl`
|`Duration`
|5 minutes
|Time-to-live

|`cacheNullOrEmpty`
|`Boolean`
|`false`
|Cache null values and empty collections
|===

=== redisDelete / redisUnlinkAsync - Cache Eviction

Removes keys from Redis cache.

[source,kotlin]
----
import com.myrealtrip.infrastructure.redis.redisDelete
import com.myrealtrip.infrastructure.redis.redisUnlinkAsync
import com.myrealtrip.infrastructure.redis.redisUnlinkByPatternAsync

// Synchronous deletion with result confirmation
val wasDeleted = redisDelete("session:${sessionId}")
if (wasDeleted) {
    logger.info { "Session cache cleared for: $sessionId" }
}

// Asynchronous deletion (fire-and-forget)
userService.deleteUser(userId)
redisUnlinkAsync("user:${userId}")

// Pattern-based bulk eviction
redisUnlinkByPatternAsync("session:user:*")
redisUnlinkByPatternAsync("flight:${airlineCode}:*")
redisUnlinkByPatternAsync("temp:import:2024-*")
----

==== redisDelete vs redisUnlinkAsync

[cols="1,2,2"]
|===
|Aspect |redisDelete |redisUnlinkAsync

|Execution
|Synchronous
|Asynchronous

|Return value
|`Boolean` (true if deleted)
|`Unit` (void)

|Use case
|Need confirmation
|Fire-and-forget

|Performance
|Blocks until complete
|Returns immediately
|===

==== Pattern Matching

Supports Redis glob patterns:

* `*` - matches any characters
* `?` - matches single character
* `[abc]` - matches one character from set
* `[a-z]` - matches one character from range

WARNING: Be careful with patterns as they can delete many keys. Always test in non-production first.

=== Key Format

All Redis keys are automatically prefixed and normalized:

[source,kotlin]
----
// Internal implementation
private fun buildCacheKey(key: String): String =
    "$REDIS_PREFIX$SEPARATOR$key".lowercase()

// Example transformations
"user:123"           -> "glory:app:user:123"
"Flight:ABC"         -> "glory:app:flight:abc"
"SEARCH:RESULTS"     -> "glory:app:search:results"
----

[cols="1,2,2"]
|===
|Component |Value |Description

|`REDIS_PREFIX`
|`glory:app`
|Application namespace prefix

|`SEPARATOR`
|`:`
|Key component separator

|Normalization
|lowercase
|All keys converted to lowercase
|===

TIP: To modify the prefix, edit `RedisConstants.REDIS_PREFIX` in the infrastructure module.

== Distributed Lock

Use `redisLock` for distributed locking across application instances.

=== Usage

[source,kotlin]
----
import com.myrealtrip.infrastructure.redis.redisLock
import java.util.concurrent.TimeUnit

// Basic lock with defaults (3s wait, 5s lease)
val result = redisLock("order:process:${orderId}") {
    orderService.processOrder(orderId)
}

// Custom wait and lease times
val payment = redisLock(
    key = "payment:${paymentId}",
    waitTime = 10,
    leaseTime = 30,
    timeUnit = TimeUnit.SECONDS
) {
    paymentService.processPayment(paymentId)
}

// Inventory update with lock
redisLock("inventory:${productId}") {
    val current = inventoryService.getStock(productId)
    inventoryService.updateStock(productId, current - quantity)
}

// Handle lock acquisition failure
try {
    redisLock("resource:${id}", waitTime = 1) {
        // critical section
    }
} catch (e: IllegalStateException) {
    logger.warn { "Resource is busy, try again later" }
}
----

=== Parameters

[cols="1,1,1,3"]
|===
|Parameter |Type |Default |Description

|`key`
|`String`
|required
|Lock key suffix (prefixed automatically)

|`waitTime`
|`Long`
|3 seconds
|Maximum time to wait for lock acquisition

|`leaseTime`
|`Long`
|5 seconds
|Maximum time to hold the lock (auto-release)

|`timeUnit`
|`TimeUnit`
|`SECONDS`
|Time unit for wait and lease times
|===

=== Behavior

* **Auto-release**: Lock is automatically released after function execution or when lease time expires
* **Thread-safe**: Only the thread holding the lock can release it
* **Failure**: Throws `IllegalStateException` if lock cannot be acquired within wait time
* **Deadlock prevention**: Lease time prevents deadlocks from application failures

== Decision Guide

=== When to Use @Cacheable (Annotation-Based)

Use Spring's `@Cacheable` for simple, declarative caching:

[cols="1,3"]
|===
|✅ Use When |❌ Don't Use When

|Simple method result caching
|Need complex cache invalidation logic

|Standard CRUD operations
|Need conditional caching based on runtime values

|Cache key is method parameters
|Need to cache partial results

|Cache eviction on update/delete
|Need fine-grained TTL control per call
|===

.Example
[source,kotlin]
----
// ✅ Good use case
@Cacheable(cacheManager = "redisCacheManager", cacheNames = [DEFAULT], key = "#id")
fun findUserById(id: Long): User?

@CacheEvict(cacheManager = "redisCacheManager", cacheNames = [DEFAULT], key = "#id")
fun updateUser(id: Long, user: User): User
----

=== When to Use redisGet (Programmatic)

Use `redisGet` for complex caching scenarios:

[cols="1,3"]
|===
|✅ Use When |❌ Don't Use When

|Need dynamic TTL based on data
|Simple method result caching is sufficient

|Want to cache null/empty results
|@Cacheable annotations work fine

|Need bypass/force refresh modes
|Don't need special cache behaviors

|Complex cache key generation
|Standard Spring caching meets requirements

|Need graceful Redis failure handling
|Want Spring's cache abstraction layer
|===

.Example
[source,kotlin]
----
// ✅ Good use case
fun getFlightPrice(flightId: String, date: LocalDate): Money {
    val ttl = if (date.isBefore(LocalDate.now().plusDays(7))) {
        Duration.ofMinutes(5)  // Short TTL for near-term flights
    } else {
        Duration.ofHours(1)    // Longer TTL for distant flights
    }

    return redisGet(
        key = "flight:${flightId}:${date}:price",
        ttl = ttl,
        cacheNullOrEmpty = true  // Cache even if no price available
    ) {
        priceService.calculatePrice(flightId, date)
    }
}
----

=== When to Avoid Caching

Don't cache in these scenarios:

[cols="1,3"]
|===
|Scenario |Reason

|Real-time data
|Cache invalidation overhead exceeds query cost

|User-specific sensitive data
|Security risk, cache key management complexity

|Large objects (>1MB)
|Memory pressure, network overhead for Redis

|Write-heavy operations
|Cache invalidation overhead too high

|Unpredictable access patterns
|Low cache hit rate, wasted memory
|===

== Best Practices

=== Cache Key Design

[source,kotlin]
----
// ✅ Good: Hierarchical, descriptive keys
"user:${userId}"
"flight:${airlineCode}:${flightNumber}:${date}"
"search:product:${category}:${query}"
"stats:daily:${date}:revenue"

// ❌ Bad: Flat, unclear keys
"u_${userId}"
"flight_data"
"search_${hashCode}"
----

=== TTL Selection

[cols="1,2,2"]
|===
|Data Type |Recommended TTL |Rationale

|Real-time data
|1-5 minutes
|Balance freshness vs DB load

|User sessions
|30 minutes - 1 hour
|Typical user interaction duration

|Reference data
|1-24 hours
|Rarely changes, safe to cache long

|Search results
|5-10 minutes
|Balance relevance vs performance

|Computed reports
|1-24 hours
|Expensive to compute, stable results
|===

=== Memory Management

[source,kotlin]
----
// ✅ Good: Cache only essential data
data class UserCacheDto(
    val id: Long,
    val name: String,
    val email: String
)

// ❌ Bad: Caching entire entity with relations
@OneToMany
val orders: List<Order> = mutableListOf()
----

=== Error Handling

All Redis functions handle failures gracefully:

[source,kotlin]
----
// No try-catch needed - handled internally
val users = redisGet("users:all") {
    userRepository.findAll()  // Executes on Redis failure
}

// Lock failures throw exception for explicit handling
try {
    redisLock("order:${id}", waitTime = 1) {
        processOrder(id)
    }
} catch (e: IllegalStateException) {
    // Handle lock acquisition failure
    logger.warn { "Order ${id} is being processed by another instance" }
}
----

== Monitoring

=== Caffeine Stats

Caffeine cache statistics are recorded and can be monitored:

[source,kotlin]
----
val cacheManager = applicationContext.getBean(CacheManager::class.java)
val cache = cacheManager.getCache("users")
if (cache is CaffeineCache) {
    val stats = cache.nativeCache.stats()
    logger.info {
        """
        Cache Stats:
        - Hits: ${stats.hitCount()}
        - Misses: ${stats.missCount()}
        - Hit Rate: ${stats.hitRate()}
        - Evictions: ${stats.evictionCount()}
        """.trimIndent()
    }
}
----

=== Redis Monitoring

Monitor Redis using Redisson's built-in tools or Redis CLI:

[source,bash]
----
# Connect to Redis
redis-cli

# View all keys with prefix
KEYS glory:app:*

# Get key TTL
TTL glory:app:user:123

# Monitor real-time commands
MONITOR

# Get memory usage
INFO memory
----

== Configuration

=== Application Properties

[source,yaml]
----
spring:
  profiles:
    include: infrastructure  # Include infrastructure profile

  redis:
    redisson:
      file: classpath:redisson-dev.yml  # Redisson configuration

  docker:
    compose:
      enabled: true  # Auto-start Redis in local/dev
      file: modules/infrastructure/docker-compose.yml
----

=== Redisson Configuration

See xref:../technical/redis-configuration.adoc[Redis Configuration Guide] for Redisson setup details.

== See Also

* xref:03-http-client-configuration.adoc[HTTP Client Configuration]
* xref:../technical/redis-configuration.adoc[Redis Configuration Guide]
* xref:../technical/performance-optimization.adoc[Performance Optimization]
* link:https://github.com/ben-manes/caffeine[Caffeine Cache Documentation]
* link:https://github.com/redisson/redisson[Redisson Documentation]
