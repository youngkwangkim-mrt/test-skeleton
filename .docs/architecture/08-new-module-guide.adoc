= New Module Guide
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 2
:sectnums:
:last-verified: 2026-02-13

== Before You Begin

=== Understanding Module Types

This project uses two types of modules:

[cols="1,1,2"]
|===
|Type |Naming Pattern |Purpose

|Library Module
|No suffix (e.g., `common`, `infrastructure`)
|Produces JAR artifacts, shared across multiple applications

|Application Module
|`-app` suffix (e.g., `skeleton-api-app`)
|Produces executable BootJar artifacts, Spring Boot applications
|===

IMPORTANT: The `-app` suffix in the module name automatically triggers Spring Boot plugin activation in the root `build.gradle.kts`. This is configured using: `configure(subprojects.filter { it.name.endsWith("-app") })`.

=== Module Dependency Rules

All modules must follow the dependency direction rules defined in xref:01-module-dependency.adoc[Module Dependency Documentation].

Key principles:

* Dependencies flow from higher layers to lower layers
* No circular dependencies allowed
* `common` module is the foundation (no dependencies on other modules)
* `-app` modules are composition roots (can depend on any module)

=== Common Module Auto-Injection

The `modules:common` module is automatically added as a dependency to all subprojects (except `common` itself) via the root `build.gradle.kts`:

[source,kotlin]
----
// Add common module to all subprojects (except common itself)
if (project.name != "common") {
    dependencies {
        implementation(project(":modules:common"))
    }
}
----

You do NOT need to manually add `common` as a dependency.

== Adding an Application Module

Application modules contain business logic orchestration, HTTP clients, and domain models. They reside under `modules/application/`.

=== Step 1: Create Directory Structure

[source,bash]
----
modules/application/my-application/
├── build.gradle.kts
└── src/main/kotlin/com/myrealtrip/myapplication/
    ├── client/
    │   ├── MyClient.kt               # @HttpExchange interface
    │   ├── MyClientConfig.kt         # Client configuration
    │   └── dto/
    │       └── MyDto.kt              # External API DTOs
    └── service/
        ├── MyService.kt              # Application service
        └── MyDomain.kt               # Domain model
----

=== Step 2: Create build.gradle.kts

Create `modules/application/my-application/build.gradle.kts`:

[source,kotlin]
----
// My Application module - External HTTP Client

dependencies {
    api(project(":modules:infrastructure"))
    api(rootProject.libs.bundles.spring.web)
}
----

Key dependencies:

* `infrastructure`: Provides `HttpLoggingInterceptor`, cache, Redis, etc.
* `spring.web`: Provides `@HttpExchange`, `RestClient`, etc.

=== Step 3: Create @HttpExchange Client Interface

Create `src/main/kotlin/com/myrealtrip/myapplication/client/MyClient.kt`:

[source,kotlin]
----
package com.myrealtrip.myapplication.client

import com.myrealtrip.myapplication.client.dto.MyDto
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.service.annotation.DeleteExchange
import org.springframework.web.service.annotation.GetExchange
import org.springframework.web.service.annotation.HttpExchange
import org.springframework.web.service.annotation.PostExchange
import org.springframework.web.service.annotation.PutExchange

@HttpExchange("/api/resource")
interface MyClient {

    @GetExchange
    fun fetchAll(): List<MyDto>

    @GetExchange("/{id}")
    fun findById(@PathVariable id: Long): MyDto

    @PostExchange
    fun create(@RequestBody dto: MyDto): MyDto

    @PutExchange("/{id}")
    fun update(@PathVariable id: Long, @RequestBody dto: MyDto): MyDto

    @DeleteExchange("/{id}")
    fun delete(@PathVariable id: Long)
}
----

=== Step 4: Create Client Configuration

Create `src/main/kotlin/com/myrealtrip/myapplication/client/MyClientConfig.kt`:

[source,kotlin]
----
package com.myrealtrip.myapplication.client

import com.myrealtrip.infrastructure.client.HttpLoggingInterceptor
import com.myrealtrip.infrastructure.client.HttpLoggingInterceptor.Level
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.HttpHeaders
import org.springframework.http.MediaType
import org.springframework.web.client.support.RestClientHttpServiceGroupConfigurer
import org.springframework.web.service.registry.ImportHttpServices

@Configuration
@ImportHttpServices(group = "my-service", types = [MyClient::class])
class MyClientConfig {

    @Bean
    fun myClientGroupConfigurer(): RestClientHttpServiceGroupConfigurer {
        return RestClientHttpServiceGroupConfigurer { groups ->
            groups.filterByName("my-service")
                .forEachClient { _, builder ->
                    builder.baseUrl("https://api.example.com")
                        .defaultHeader(HttpHeaders.ACCEPT, MediaType.APPLICATION_JSON_VALUE)
                        .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                        .requestInterceptor(HttpLoggingInterceptor("MyClient", Level.SIMPLE))
                }
        }
    }
}
----

Key configurations:

* `@ImportHttpServices`: Registers the client interface with a group name
* `RestClientHttpServiceGroupConfigurer`: Configures base URL, headers, and interceptors
* `HttpLoggingInterceptor`: Provides HTTP request/response logging

Available logging levels:

* `NONE`: No logging
* `SIMPLE`: Request method, URL, and response status
* `HEADERS`: Simple + headers
* `BODY`: Headers + request/response body (default)

=== Step 5: Create Service and Domain Model

Create `src/main/kotlin/com/myrealtrip/myapplication/service/MyService.kt`:

[source,kotlin]
----
package com.myrealtrip.myapplication.service

import com.myrealtrip.common.codes.response.ErrorCode
import com.myrealtrip.common.exceptions.KnownException
import com.myrealtrip.myapplication.client.MyClient
import com.myrealtrip.myapplication.client.dto.MyDto
import org.springframework.stereotype.Service

@Service
class MyService(
    private val myClient: MyClient
) {

    fun findAll(): List<MyDomain> {
        return myClient.fetchAll().map { MyDomain.from(it) }
    }

    fun findById(id: Long): MyDomain {
        return runCatching { myClient.findById(id) }
            .map { MyDomain.from(it) }
            .getOrElse { throw MyNotFoundException(id) }
    }

    fun create(title: String): MyDomain {
        val dto = MyDto(id = 0, title = title)
        return MyDomain.from(myClient.create(dto))
    }
}

class MyNotFoundException(id: Long) : KnownException(
    ErrorCode.DATA_NOT_FOUND,
    "Resource not found: $id"
)
----

Create `src/main/kotlin/com/myrealtrip/myapplication/service/MyDomain.kt`:

[source,kotlin]
----
package com.myrealtrip.myapplication.service

import com.myrealtrip.myapplication.client.dto.MyDto

data class MyDomain(
    val id: Long,
    val title: String
) {
    companion object {
        fun from(dto: MyDto): MyDomain = MyDomain(
            id = dto.id,
            title = dto.title
        )
    }
}
----

=== Step 6: Register in settings.gradle.kts

Add the module to `settings.gradle.kts`:

[source,kotlin]
----
include(
    // Foundation
    "modules:common",
    "modules:common-web",

    // Infrastructure
    "modules:infrastructure",

    // Core Business
    "modules:application:todo-application",
    "modules:application:my-application",  // <-- Add here

    // Runtime
    "modules:bootstrap:skeleton-api-app",
    "modules:bootstrap:skeleton-worker-app",
)
----

=== Step 7: Add Dependency in Bootstrap Module

Add the application module as a dependency in the bootstrap app's `build.gradle.kts`:

[source,kotlin]
----
// modules/bootstrap/skeleton-api-app/build.gradle.kts

dependencies {
    implementation(project(":modules:application:todo-application"))
    implementation(project(":modules:application:my-application"))  // <-- Add here
}
----

=== Step 8: Verify Build

[source,bash]
----
./gradlew :modules:application:my-application:build
----

== Adding a Bootstrap App Module

Bootstrap app modules are executable Spring Boot applications. They reside under `modules/bootstrap/`.

=== Step 1: Create Directory Structure

[source,bash]
----
modules/bootstrap/my-service-app/
├── build.gradle.kts
└── src/main/
    ├── kotlin/com/myrealtrip/myserviceapp/
    │   ├── Application.kt
    │   ├── AppWebConfig.kt
    │   ├── api/
    │   │   └── MyController.kt
    │   └── config/
    │       └── AppConfig.kt
    └── resources/
        └── application.yml
----

=== Step 2: Create build.gradle.kts

Create `modules/bootstrap/my-service-app/build.gradle.kts`:

[source,kotlin]
----
// Bootstrap Application module

dependencies {
    val developmentOnly by configurations

    implementation(project(":modules:application:my-application"))

    // Development
    developmentOnly(rootProject.libs.spring.boot.docker.compose)
}

tasks.processResources {
    filesMatching("**/application*.yml") {
        filter<org.apache.tools.ant.filters.ReplaceTokens>(
            "tokens" to mapOf("projectVersion" to project.version.toString())
        )
    }
}
----

IMPORTANT: The `-app` suffix automatically activates:

* Spring Boot plugin (`bootJar` task enabled)
* Auto-injection of `common-web` and `infrastructure` dependencies
* JAR task disabled (only BootJar is produced)

=== Step 3: Create Application.kt

Create `src/main/kotlin/com/myrealtrip/Application.kt`:

[source,kotlin]
----
package com.myrealtrip

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
import org.springframework.cache.annotation.EnableCaching
import org.springframework.scheduling.annotation.EnableAsync
import org.springframework.scheduling.annotation.EnableScheduling

@SpringBootApplication
@EnableCaching
@EnableAsync
@EnableScheduling
class Application

fun main(args: Array<String>) {
    runApplication<Application>(*args)
}
----

Key annotations:

* `@SpringBootApplication`: Component scanning, auto-configuration
* `@EnableCaching`: Activates Spring Cache abstraction
* `@EnableAsync`: Enables asynchronous method execution
* `@EnableScheduling`: Enables `@Scheduled` tasks

=== Step 4: Create AppWebConfig.kt

Create `src/main/kotlin/com/myrealtrip/myserviceapp/AppWebConfig.kt`:

[source,kotlin]
----
package com.myrealtrip.myserviceapp

import org.springframework.context.annotation.Configuration
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer

@Configuration
class AppWebConfig : WebMvcConfigurer {
    // Add custom interceptors, CORS, etc. if needed
}
----

This configuration class is optional but recommended for adding:

* Custom interceptors
* CORS configuration
* Resource handlers
* View controllers

=== Step 5: Create application.yml

Create `src/main/resources/application.yml`:

[source,yaml]
----
spring:
  application:
    name: my-service-app
    version: @projectVersion@

  profiles:
    default: local
    group:
      embed: embed, local
    include: common-web, infrastructure

  servlet:
    multipart:
      enabled: true
      max-file-size: 10MB
      max-request-size: 10MB

  threads:
    virtual:
      enabled: false

  task:
    scheduling:
      pool:
        size: 10

# server
server:
  tomcat:
    accept-count: 500
    max-connections: 10000


# =====================================================================================================================
# local
# =====================================================================================================================
---
spring:
  config:
    activate:
      on-profile: local

logging:
  level:
    app: trace
    sql: debug
    query: debug
    bind: trace
    hikari: debug

  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} %clr(%5.5p) [%15.15t] [%clr(%-32.32X{traceId:-}){magenta},%clr(%-16.16X{spanId:-})] --- %clr(%-40.40logger{39}){cyan} : %m%n%throwable"


# =====================================================================================================================
# prod
# =====================================================================================================================
---
spring:
  config:
    activate:
      on-profile: prod

logging:
  level:
    app: info
    sql: info
    query: info
    bind: info
    hikari: info
  structured:
    format:
      console: logstash
    json:
      add:
        app-name: my-service-app
        app-version: @projectVersion@
----

Key configurations:

* `spring.profiles.include: common-web, infrastructure`: Imports shared configurations
* `@projectVersion@`: Replaced by Gradle during `processResources` task
* Profile-specific logging: `local` (verbose) vs `prod` (structured JSON)

=== Step 6: Register in settings.gradle.kts

Add the module to `settings.gradle.kts`:

[source,kotlin]
----
include(
    // Foundation
    "modules:common",
    "modules:common-web",

    // Infrastructure
    "modules:infrastructure",

    // Core Business
    "modules:application:my-application",

    // Runtime
    "modules:bootstrap:skeleton-api-app",
    "modules:bootstrap:skeleton-worker-app",
    "modules:bootstrap:my-service-app",  // <-- Add here
)
----

=== Step 7: Verify Build

[source,bash]
----
./gradlew :modules:bootstrap:my-service-app:bootJar
----

== Adding a Controller

Controllers expose REST APIs in bootstrap app modules.

=== Basic Controller Structure

Create `src/main/kotlin/com/myrealtrip/myserviceapp/api/MyController.kt`:

[source,kotlin]
----
package com.myrealtrip.myserviceapp.api

import com.myrealtrip.common.annoatations.LogResponseBody
import com.myrealtrip.commonweb.response.resource.ApiResource
import com.myrealtrip.myapplication.service.MyService
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api/v1/my-resource")
class MyController(
    private val myService: MyService
) {

    @GetMapping
    fun findAll() = ApiResource.success(myService.findAll())

    @GetMapping("/{id}")
    @LogResponseBody
    fun findById(@PathVariable id: Long) = ApiResource.success(myService.findById(id))

    @PostMapping
    fun create(@RequestBody request: CreateRequest) =
        ApiResource.success(myService.create(request.title))
}

data class CreateRequest(val title: String)
----

=== Response Format

All controllers must return `ApiResource<T>`:

[source,kotlin]
----
// Success with data
ApiResource.success(data)

// Success without data
ApiResource.success()

// Page response
ApiResource.ofPage(pageData)
----

Response structure:

[source,json]
----
{
  "status": {
    "status": 200,
    "code": "SUCCESS",
    "message": "Operation successful"
  },
  "meta": {
    "size": 1
  },
  "data": { ... }
}
----

=== Exception Handling

Exceptions are automatically handled by `GlobalExceptionHandlerV2` (from `common-web`):

* `KnownException`: Returns 200 with error status (expected errors)
* `BizRuntimeException`: Returns 500 with error details
* Other exceptions: Generic 500 error response

No need to wrap service calls in try-catch blocks.

=== Available Annotations

[cols="1,2"]
|===
|Annotation |Purpose

|`@LogResponseBody`
|Logs the response body after method execution

|`@ExcludeRequestLog`
|Excludes this endpoint from request logging

|`@CheckIp(allowedIps = ["..."])`
|Restricts access to specific IP addresses
|===

Example:

[source,kotlin]
----
@GetMapping("/{id}")
@LogResponseBody
@CheckIp(allowedIps = ["127.0.0.1", "10.0.0.0/8"])
fun findById(@PathVariable id: Long) = ApiResource.success(myService.findById(id))
----

== Checklist

=== Application Module Checklist

Before considering the module complete:

* [ ] `build.gradle.kts` created with `infrastructure` and `spring.web` dependencies
* [ ] `@HttpExchange` client interface created
* [ ] Client configuration with `@ImportHttpServices` created
* [ ] Service class with business logic created
* [ ] Domain model created
* [ ] Module registered in `settings.gradle.kts`
* [ ] Dependency added to bootstrap app's `build.gradle.kts`
* [ ] Module builds successfully: `./gradlew :modules:application:{name}:build`

=== Bootstrap App Module Checklist

Before considering the module complete:

* [ ] Module name ends with `-app` suffix
* [ ] `build.gradle.kts` created with `processResources` task
* [ ] `Application.kt` created with required annotations
* [ ] `AppWebConfig.kt` created
* [ ] `application.yml` created with `common-web`, `infrastructure` includes
* [ ] Module registered in `settings.gradle.kts`
* [ ] Application module dependencies added
* [ ] BootJar builds successfully: `./gradlew :modules:bootstrap:{name}:bootJar`
* [ ] Application starts: `./gradlew :modules:bootstrap:{name}:bootRun`

=== Controller Checklist

Before considering the controller complete:

* [ ] Controller is in `api/` package under bootstrap app
* [ ] All methods return `ApiResource<T>`
* [ ] Service dependencies injected via constructor
* [ ] Request/response DTOs defined
* [ ] Appropriate annotations applied (`@LogResponseBody`, etc.)
* [ ] API endpoints tested manually or with integration tests
