= Common Module
:doctype: book
:icons: font
:source-highlighter: highlightjs
:toc: left
:toclevels: 3
:sectnums:

공통 유틸리티, 값 객체, 예외 처리를 제공하는 기반 모듈입니다.

다른 모듈에 의존하지 않는 최하위 레이어입니다.

== Overview

[cols="1,3"]
|===
| 패키지 | 설명

| `codes`
| 응답 코드 (SuccessCode, ErrorCode)

| `exceptions`
| 예외 클래스 (BizException, KnownException)

| `values`
| 타입 안전한 값 객체 (Email, PhoneNumber, Money, Rate)

| `utils/datetime`
| 날짜/시간 유틸리티

| `utils/extensions`
| Kotlin 확장 함수 (String, Number, DateTime, UUID)

| `utils/cipher`
| 암호화 유틸리티 (AES)

| `utils/coroutine`
| 코루틴 유틸리티 (MDC 지원)

| `annotations`
| AOP 기반 커스텀 어노테이션
|===

== Values

타입 안전한 값 객체입니다. JVM inline class를 활용하여 런타임 오버헤드 없이 타입 안전성을 제공합니다.

=== Email

타입 안전한 이메일 값 객체입니다.

==== 생성

[source,kotlin]
----
// 문자열에서 생성
val email = Email.of("user@example.com")

// null 반환 (유효하지 않은 경우)
val emailOrNull = Email.ofOrNull("invalid")

// 확장 프로퍼티 사용
val email = "user@example.com".asEmail
val emailOrNull = "user@example.com".asEmailOrNull
----

==== 유효성 검사

[source,kotlin]
----
Email.isValid("user@example.com")  // true
Email.isValid("invalid")           // false
----

==== 속성

[source,kotlin]
----
val email = "user@example.com".asEmail
email.localPart       // "user"
email.domain          // "example.com"
email.topLevelDomain  // "com"
----

==== 마스킹

[source,kotlin]
----
val email = "username@example.com".asEmail
email.masked()                  // "us******@example.com"
email.masked(visibleChars = 3)  // "use*****@example.com"
----

=== PhoneNumber

Google libphonenumber 기반의 타입 안전한 전화번호 값 객체입니다.

==== 생성

[source,kotlin]
----
// 기본 생성 (한국 번호)
val phone = PhoneNumber.of("010-1234-5678")
val phone = PhoneNumber.of("01012345678")

// 다른 국가 번호
val usPhone = PhoneNumber.of("+1-555-123-4567", region = "US")

// E.164 형식에서 생성
val phone = PhoneNumber.ofE164("+821012345678")

// 확장 프로퍼티 사용
val phone = "010-1234-5678".asPhoneNumber
val phone = "010-1234-5678".asPhoneNumberOrNull
----

==== 유효성 검사

[source,kotlin]
----
PhoneNumber.isValid("010-1234-5678")        // true
PhoneNumber.isValidMobile("010-1234-5678")  // true (모바일 번호)
PhoneNumber.isValidMobile("02-1234-5678")   // false (일반 전화)
----

==== 포맷팅

[source,kotlin]
----
val phone = "01012345678".asPhoneNumber

phone.toE164()          // "+821012345678"
phone.toNational()      // "010-1234-5678"
phone.toInternational() // "+82 10-1234-5678"
phone.toRfc3966()       // "tel:+82-10-1234-5678"
----

==== 속성

[source,kotlin]
----
val phone = "010-1234-5678".asPhoneNumber

phone.countryCode    // 82
phone.nationalNumber // 1012345678
phone.regionCode     // "KR"
phone.isMobile       // true
phone.isFixedLine    // false
----

==== 마스킹

[source,kotlin]
----
val phone = "010-1234-5678".asPhoneNumber

phone.masked()                    // "***-****-5678"
phone.masked(visibleDigits = 2)   // "***-****-**78"
phone.maskedInternational()       // "+82 **-****-5678"
phone.toString()                  // "***-****-5678" (기본 출력)
----

=== Money

다중 통화를 지원하는 타입 안전한 금액 값 객체입니다.

==== 생성

[source,kotlin]
----
// BigDecimal, Long, Double, String 지원
val money = Money.of(10000, "KRW")
val money = Money.of(BigDecimal("99.99"), "USD")

// 편의 메서드
val krw = Money.krw(10000)
val usd = Money.usd(99.99)
val eur = Money.eur("49.99")

// 영점
val zero = Money.zero(Currency.getInstance("KRW"))

// 확장 프로퍼티
val money = 10000L.krw
val money = 99.99.usd
----

==== 산술 연산

[source,kotlin]
----
val a = Money.krw(10000)
val b = Money.krw(5000)

a + b           // 15,000 KRW
a - b           // 5,000 KRW
a * 2           // 20,000 KRW
a / 2           // 5,000 KRW
-a              // -10,000 KRW
----

WARNING: 동일한 통화끼리만 덧셈/뺄셈이 가능합니다. 다른 통화 연산 시 `IllegalArgumentException`이 발생합니다.

==== 비교

[source,kotlin]
----
val money = Money.krw(10000)

money.isZero()                        // false
money.isPositive()                    // true
money.isNegative()                    // false
money.isGreaterThan(Money.krw(5000))  // true
money.isLessThan(Money.krw(20000))    // true
----

==== Rate 적용

[source,kotlin]
----
val price = Money.krw(10000)
val discountRate = Rate.ofPercent(10)

price.applyRate(discountRate)          // 1,000 KRW (할인 금액)
price.remainderAfterRate(discountRate) // 9,000 KRW (할인 후 금액)
price.addRate(discountRate)            // 11,000 KRW (세금 추가)
----

==== 포맷팅

[source,kotlin]
----
val krw = Money.krw(10000)
val usd = Money.usd(99.99)

krw.format()          // "₩10,000"
usd.format()          // "$99.99"
krw.formatWithCode()  // "10,000 KRW"
----

=== Rate

타입 안전한 비율/퍼센트 값 객체입니다.

==== 생성

[source,kotlin]
----
// 소수점 형태 (0.15 = 15%)
val rate = Rate.of(0.15)
val rate = Rate.of(BigDecimal("0.15"))

// 퍼센트 형태 (15 = 15%)
val rate = Rate.ofPercent(15)
val rate = Rate.ofPercent(BigDecimal("15"))

// 상수
val zero = Rate.ZERO
val half = Rate.HALF
val tenPercent = Rate.TEN_PERCENT

// 확장 프로퍼티
val rate = 15.percent   // 15%
val rate = 0.15.asRate  // 15%
----

==== 변환

[source,kotlin]
----
val rate = Rate.ofPercent(15)

rate.toDecimal()       // 0.1500
rate.toPercent()       // 15.0000
rate.toPercentString() // "15%"
----

==== 적용

[source,kotlin]
----
val rate = Rate.ofPercent(10)

rate.applyTo(BigDecimal("10000"))     // 1000 (10% of 10000)
rate.remainderOf(BigDecimal("10000")) // 9000 (90% of 10000)
----

== Exceptions

=== 예외 계층

[cols="1,2,1,1"]
|===
| 예외 클래스 | 용도 | 타입 | 스택 트레이스

| `BizException`
| 복구 가능한 비즈니스 에러
| Checked
| 설정 가능

| `BizRuntimeException`
| 복구 불가능한 비즈니스 에러
| Unchecked
| 설정 가능

| `KnownException`
| 예상된 에러 (validation, not found)
| Unchecked
| 항상 비활성화
|===

=== 사용 예시

[source,kotlin]
----
// 예상된 에러 - 스택 트레이스 없이 로깅
class UserNotFoundException(id: Long) : KnownException(
    ErrorCode.DATA_NOT_FOUND,
    "User not found: $id"
)

// 비즈니스 에러 - 스택 트레이스 포함 로깅
throw BizRuntimeException(
    ErrorCode.ILLEGAL_STATE,
    "Cannot process order in current state"
)
----

=== ErrorCode

[source,kotlin]
----
// 주요 에러 코드
ErrorCode.UNAUTHORIZED          // 401 - 인증 실패
ErrorCode.FORBIDDEN             // 403 - 권한 없음
ErrorCode.NOT_FOUND             // 404 - 리소스 없음
ErrorCode.INVALID_ARGUMENT      // 400 - 잘못된 요청
ErrorCode.ILLEGAL_ARGUMENT      // 406 - 유효하지 않은 인자
ErrorCode.DATA_NOT_FOUND        // 406 - 데이터 없음
ErrorCode.SERVER_ERROR          // 500 - 서버 에러
----

== Preconditions

조건 실패 시 `KnownException`을 던지는 검증 함수입니다.

[source,kotlin]
----
// boolean 검사
knownRequired(amount > 0) { "Amount must be positive" }

// null 검사
val user = knownRequiredNotNull(userRepository.findById(id)) {
    "User not found: $id"
}

// blank 검사
val name = knownNotBlank(request.name) { "Name is required" }
----

== Date/Time Utilities

=== DateFormatter

날짜/시간 포맷팅 및 파싱 유틸리티입니다.

==== 포맷 상수

[cols="1,2,2"]
|===
| 상수 | 패턴 | 예시

| `DATE_FORMAT`
| yyyy-MM-dd
| 2025-01-24

| `DATE_TIME_FORMAT`
| yyyy-MM-dd'T'HH:mm:ss
| 2025-01-24T14:30:00

| `NUMERIC_DATE`
| yyyyMMdd
| 20250124

| `KOREAN_DATE`
| yyyy년 MM월 dd일
| 2025년 01월 24일
|===

==== 파싱

[source,kotlin]
----
// 문자열 → 날짜/시간
"2025-01-24".toDate()                    // LocalDate
"2025-01-24T14:30:00".toDateTime()       // LocalDateTime
"14:30:00".toTime()                      // LocalTime

// 숫자형 문자열 파싱
"20250124".numericToDate()               // LocalDate
"20250124143000".numericToDateTime()     // LocalDateTime
----

==== 포맷팅

[source,kotlin]
----
val date = LocalDate.now()
val dateTime = LocalDateTime.now()

// 기본 포맷
date.toStr()          // "2025-01-24"
dateTime.toStr()      // "2025-01-24T14:30:00"

// 숫자형 포맷
date.toNumericStr()   // "20250124"

// 한국어 포맷
date.toKorean()       // "2025년 01월 24일"
dateTime.toKorean()   // "2025년 01월 24일 14시 30분 00초"
----

==== 요일 변환

[source,kotlin]
----
// 문자열 → DayOfWeek
"MON".toDayOfWeek()   // DayOfWeek.MONDAY
"월".toDayOfWeek()    // DayOfWeek.MONDAY
"월요일".toDayOfWeek() // DayOfWeek.MONDAY

// DayOfWeek → 문자열
DayOfWeek.MONDAY.toTwoLetter()           // "MO"
DayOfWeek.MONDAY.toThreeLetter()         // "MON"
DayOfWeek.MONDAY.toKorean()              // "월요일"
DayOfWeek.MONDAY.toKorean(short = true)  // "월"
----

=== SearchDates

날짜 범위 검색을 위한 유틸리티입니다.

==== 생성

[source,kotlin]
----
// 기본 생성
val dates = SearchDates.of(
    startDate = LocalDate.of(2025, 1, 1),
    endDate = LocalDate.of(2025, 1, 31)
)

// 편의 메서드
val today = SearchDates.today()
val yesterday = SearchDates.yesterday()
val lastWeek = SearchDates.lastDays(7)
val lastMonth = SearchDates.lastMonth()
val thisMonth = SearchDates.thisMonth()
----

==== 기능

[source,kotlin]
----
val dates = SearchDates.lastMonth()

// 포함 여부 확인
LocalDate.now() in dates  // operator 'in' 지원

// 기간 정보
dates.period()        // Period
dates.daysBetween()   // Long
----

=== Range Classes

날짜/시간 범위를 표현하는 클래스입니다.

[cols="1,2"]
|===
| 클래스 | 용도

| `LocalDateRange`
| LocalDate 범위

| `LocalDateTimeRange`
| LocalDateTime 범위

| `LocalTimeRange`
| LocalTime 범위

| `ZonedDateTimeRange`
| ZonedDateTime 범위
|===

==== 사용 예시

[source,kotlin]
----
val range = LocalDateRange.from(
    LocalDate.of(2025, 1, 1),
    LocalDate.of(2025, 12, 31)
)

// 포함 여부
LocalDate.of(2025, 6, 15) in range  // true

// 범위 겹침 확인
val otherRange = LocalDateRange.from(
    LocalDate.of(2025, 6, 1),
    LocalDate.of(2026, 6, 30)
)
range.overlaps(otherRange)   // true
range.intersect(otherRange)  // LocalDateRange(2025-06-01 ~ 2025-12-31)

// 기간 계산
range.daysBetween()    // 365
range.monthsBetween()  // 12
----

== String Extensions

=== 마스킹

개인정보 마스킹 함수입니다.

[source,kotlin]
----
// 일반 마스킹
"1234567890".mask()                    // "******7890"
"1234567890".mask(start = 0, end = 4)  // "****567890"

// 이름 마스킹
"홍길동".maskName()   // "홍*동"
"John".maskName()     // "J**n"
"김철수".maskName()   // "김*수"

// 숫자 마스킹 (형식 유지)
"010-1234-5678".maskDigits()                   // "***-****-5678"
"010-1234-5678".maskDigits(visibleDigits = 2)  // "***-****-**78"

// 이메일 마스킹
"user@example.com".maskEmail()  // "us**@example.com"
----

=== 문자열 유틸리티

[source,kotlin]
----
// null/blank 처리
val value: String? = null
value.ifNullOrBlank("default")   // "default"
"  ".ifNullOrBlank("default")    // "default"
"hello".ifNullOrBlank("default") // "hello"

// 공백 제거
"hello world".removeAllSpaces()  // "helloworld"
----

== Number Extensions

=== 랜덤 숫자 생성

[source,kotlin]
----
randomZeroOrOne()           // 0 또는 1
randomZeroToTwo()           // 0, 1, 또는 2
randomIntBetween(1, 100)    // 1~100 사이 정수
randomLongBetween(1L, 100L) // 1~100 사이 Long

// 특정 자릿수 랜덤 숫자
randomOfLength(DigitLength.SIX)  // 100000~999999
----

=== 포맷팅

[source,kotlin]
----
1234567.commaSeparated()    // "1,234,567"
1234.56.commaSeparated(2)   // "1,234.56"
----

== DateTime Extensions

[source,kotlin]
----
val date = LocalDate.now()

// 날짜 비교
date.isToday()     // true
date.isYesterday() // false
date.isTomorrow()  // false
date.isPast()      // false
date.isFuture()    // false

// 나이 계산
val birthDate = LocalDate.of(1990, 1, 1)
birthDate.getAge()        // 만 나이
birthDate.getKoreanAge()  // 한국 나이 (태어난 해 = 1살)
----

== UUID Extensions

UUID v7에서 타임스탬프를 추출합니다.

[source,kotlin]
----
val uuid = Uuid.parse("018d5f9c-...")  // UUID v7

uuid.extractTimestamp()                            // Unix timestamp (ms)
uuid.extractLocalDateTime(ZoneId.of("Asia/Seoul")) // LocalDateTime
----

== Cipher Utilities

=== AesCipher

AES 암호화/복호화 유틸리티입니다.

[source,kotlin]
----
val key = "your-secret-key-16"  // 16, 24, 32 bytes
val iv = "initialization-v"     // 16 bytes (CBC 모드)
val plainText = "sensitive data"

// CBC 모드 (권장)
val encrypted = AesCipher.encrypt(plainText, key, iv, AesMode.CBC)
val decrypted = AesCipher.decrypt(encrypted, key, iv, AesMode.CBC)

// ECB 모드 (IV 불필요)
val encrypted = AesCipher.encrypt(plainText, key, mode = AesMode.ECB)
----

=== UrlCodec

URL 인코딩/디코딩 유틸리티입니다.

[source,kotlin]
----
UrlCodec.encode("hello world")  // "hello+world"
UrlCodec.decode("hello+world")  // "hello world"
----

== Coroutine Utilities

MDC (Mapped Diagnostic Context)를 유지하는 코루틴 유틸리티입니다.

[source,kotlin]
----
// MDC 컨텍스트를 유지하며 실행
runBlockingWithMDC {
    // MDC 값이 유지됨
}

// 비동기 실행
coroutineScope {
    asyncWithMDC { /* ... */ }
    launchWithMDC { /* ... */ }
}

// 로깅과 함께 실행
withLogging("processOrder") {
    // 시작/종료 로그 자동 출력
}
----

== Other Utilities

=== StopWatch

실행 시간을 측정합니다.

[source,kotlin]
----
val (elapsedMs, result) = stopWatch("API Call") {
    // 측정할 코드
    apiClient.call()
}
// 로그: [API Call] elapsed time: 123 ms
----

=== DynamicPair

확장된 튜플 타입입니다.

[source,kotlin]
----
// 4-tuple
val quartet: Quartet<A, B, C, D> = a and b and c and d

// 5-tuple
val quintet: Quintet<A, B, C, D, E> = a and b and c and d and e

// 리스트 변환
quartet.toList()  // List<Any?>
----

== Annotations

AOP 기반 커스텀 어노테이션입니다.

[cols="1,2"]
|===
| 어노테이션 | 용도

| `@LogTrace`
| 메서드 로깅 활성화

| `@LogResponseBody`
| 응답 바디 로깅 제어

| `@ExcludeLogTrace`
| 로그 트레이싱 제외

| `@ExcludeRequestLog`
| 요청 로깅 제외

| `@CheckIp`
| IP 기반 접근 제어
|===

[source,kotlin]
----
@LogTrace(logLevel = Level.DEBUG)
fun processOrder(order: Order) { }

@LogResponseBody(maxLength = 1000, printAll = false)
fun getUsers(): List<User> { }

@CheckIp(allowedIps = ["10.0.0.1", "10.0.0.2"])
fun adminOperation() { }
----

== Global Constants

=== TraceHeader

트레이스 ID HTTP 헤더 상수입니다.

[source,kotlin]
----
TraceHeader.APP_TRACE_ID    // "X-ZZ-TraceId"
TraceHeader.X_B3_TRACE_ID   // "X-B3-TraceId"
----

=== 제외 경로

필터/인터셉터 제외 경로입니다.

* `FILTER_EXCLUDE_PATH`: 필터 제외 경로
* `INTERCEPTOR_EXCLUDE_PATH`: 인터셉터 제외 경로

== Best Practices

[IMPORTANT]
====
**KnownException 사용 시점**

예상된 오류(validation 실패, 데이터 없음)에 사용하세요.
Stack trace를 출력하지 않아 로그가 간결해집니다.
====

[IMPORTANT]
====
**Value 객체 사용**

원시 타입(String, Long) 대신 Email, PhoneNumber, Money, Rate를 사용하세요.
컴파일 타임에 타입 안전성을 보장합니다.
====

[TIP]
====
**Money 연산 시 주의**

동일 통화끼리만 덧셈/뺄셈이 가능합니다.
환율 변환이 필요한 경우 별도 서비스를 구현하세요.
====

== Dependencies

이 모듈은 다음 라이브러리에 의존합니다:

* `com.googlecode.libphonenumber:libphonenumber` - 전화번호 파싱
* `org.jetbrains.kotlinx:kotlinx-coroutines-slf4j` - 코루틴 MDC 지원
